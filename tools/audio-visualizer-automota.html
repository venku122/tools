<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Automota Audio Visualizer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        color-scheme: light;
        --bg: #f4f1ea;
        --panel: #fffdf9;
        --ink: #1f1c17;
        --muted: #5d564d;
        --accent: #3d6b8a;
        --accent-strong: #26465c;
        --border: rgba(31, 28, 23, 0.12);
        --shadow: 0 16px 32px rgba(31, 28, 23, 0.12);
        --font-display: "Space Grotesk", "Segoe UI", sans-serif;
        --font-body: "IBM Plex Sans", "Segoe UI", sans-serif;
        --font-mono: "IBM Plex Mono", "SFMono-Regular", monospace;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--font-body);
        color: var(--ink);
        background: radial-gradient(circle at top, #d5e9f7 0%, transparent 60%),
          linear-gradient(180deg, var(--bg), #f8f5ef 100%);
        min-height: 100vh;
      }

      header {
        max-width: 1200px;
        margin: 0 auto;
        padding: 48px 20px 24px;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        text-decoration: none;
        color: var(--accent-strong);
        font-weight: 600;
        font-size: 0.95rem;
      }

      h1 {
        font-family: var(--font-display);
        font-size: clamp(2rem, 4vw, 3rem);
        margin: 16px 0 8px;
      }

      header p {
        margin: 0;
        color: var(--muted);
        font-size: 1.05rem;
        max-width: 760px;
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px 40px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
      }

      .panel {
        background: var(--panel);
        border-radius: 20px;
        border: 1px solid var(--border);
        padding: 20px;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 12px;
        animation: rise 520ms ease both;
      }

      .panel h2 {
        margin: 0;
        font-family: var(--font-display);
        font-size: 1.2rem;
      }

      label {
        font-weight: 600;
        font-size: 0.95rem;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .control-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      select,
      input[type="file"],
      input[type="range"],
      input[type="checkbox"] {
        font-family: var(--font-body);
      }

      input[type="file"],
      select {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 10px 12px;
        background: #fff;
      }

      input[type="range"] {
        width: 100%;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 10px 16px;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        background: var(--accent);
        color: #fff;
        transition: transform 160ms ease, box-shadow 160ms ease;
        box-shadow: 0 12px 20px rgba(61, 107, 138, 0.25);
      }

      button.secondary {
        background: transparent;
        color: var(--accent-strong);
        border: 1px solid rgba(61, 107, 138, 0.35);
        box-shadow: none;
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
      }

      .status {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .status[data-tone="error"] {
        color: #9b2d2d;
      }

      .status[data-tone="success"] {
        color: #2b6f4a;
      }

      .canvas-wrap {
        border-radius: 16px;
        border: 1px solid rgba(31, 28, 23, 0.2);
        background: #000;
        overflow: hidden;
        min-height: 360px;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      textarea {
        width: 100%;
        min-height: 140px;
        border-radius: 14px;
        border: 1px solid var(--border);
        padding: 12px;
        font-family: var(--font-mono);
        font-size: 0.9rem;
        background: #ffffff;
        resize: vertical;
      }

      footer {
        max-width: 1200px;
        margin: 0 auto 32px;
        padding: 0 20px;
        font-size: 0.9rem;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
      }

      footer a {
        color: var(--accent-strong);
        text-decoration: none;
        font-weight: 600;
      }

      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .panel,
        button {
          animation: none;
          transition: none;
        }
      }

      @media (max-width: 700px) {
        header {
          padding-top: 36px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <a class="back-link" href="../index.html">Back to tools</a>
      <h1>Automota Audio Visualizer</h1>
      <p>Feed an audio track or microphone into a living cellular automata visualizer inspired by AidanMM&#39;s AudioVisualizerAutomota, updated with modern JavaScript.</p>
    </header>

    <main>
      <section class="panel">
        <h2>Audio setup</h2>
        <div class="control-group">
          <label for="audioFile">Upload audio</label>
          <input id="audioFile" type="file" accept="audio/*">
        </div>
        <div class="control-group">
          <label for="audioSource">Audio source</label>
          <select id="audioSource">
            <option value="file" selected>Uploaded audio</option>
            <option value="mic">Microphone</option>
          </select>
        </div>
        <div class="control-group">
          <label for="audioEffect">Audio effect</label>
          <select id="audioEffect">
            <option value="none" selected>No effect</option>
            <option value="reverb">Reverb wash</option>
            <option value="filter">Lowpass filter</option>
          </select>
        </div>
        <div class="control-group">
          <label for="reverbStrength">Reverb strength</label>
          <input id="reverbStrength" type="range" min="0.05" max="1" step="0.05" value="0.3">
        </div>
        <div class="control-group">
          <label for="filterFrequency">Filter frequency</label>
          <input id="filterFrequency" type="range" min="120" max="2000" step="20" value="440">
        </div>
        <label class="toggle" for="monitorOutput">
          <input id="monitorOutput" type="checkbox" checked>
          Monitor audio output
        </label>
        <div class="actions">
          <button id="startButton">Start visualizer</button>
          <button id="stopButton" class="secondary" disabled>Stop</button>
        </div>
        <p class="status" id="audioStatus" role="status" aria-live="polite">Load an audio file or switch to microphone input.</p>
      </section>

      <section class="panel">
        <h2>Visualizer controls</h2>
        <div class="control-group">
          <label for="lineStyle">Line style</label>
          <select id="lineStyle">
            <option value="straight">Straight lines</option>
            <option value="quadratic" selected>Quadratic curves</option>
            <option value="cubic">Cubic curves</option>
            <option value="random">Random mix</option>
          </select>
        </div>
        <div class="control-group">
          <label for="lineWidth">Line width</label>
          <input id="lineWidth" type="range" min="0.2" max="6" step="0.1" value="1">
        </div>
        <div class="control-group">
          <label for="cellSize">Cell size</label>
          <input id="cellSize" type="range" min="0.6" max="6" step="0.1" value="1">
        </div>
        <label class="toggle" for="drawLines">
          <input id="drawLines" type="checkbox" checked>
          Draw lines
        </label>
        <label class="toggle" for="drawCells">
          <input id="drawCells" type="checkbox" checked>
          Draw cells
        </label>
        <label class="toggle" for="pixelFilter">
          <input id="pixelFilter" type="checkbox">
          Pixel filter
        </label>
        <label class="toggle" for="useWaveform">
          <input id="useWaveform" type="checkbox">
          Use waveform data
        </label>
        <label class="toggle" for="limitMotion">
          <input id="limitMotion" type="checkbox">
          Reduce motion (10 fps)
        </label>
      </section>

      <section class="panel">
        <h2>Visualizer output</h2>
        <div class="canvas-wrap">
          <canvas id="visualizer" aria-label="Audio visualizer canvas" role="img"></canvas>
        </div>
        <div class="actions">
          <button id="resetButton" class="secondary">Reset automota</button>
          <button id="copySettings">Copy settings</button>
        </div>
        <label for="settingsOutput">Settings snapshot</label>
        <textarea id="settingsOutput" readonly></textarea>
        <p class="status" id="visualStatus" role="status" aria-live="polite">Visualizer idle.</p>
      </section>
    </main>

    <footer>
      <a href="#" id="sourceLink">View source</a>
      <a href="#" id="transcriptLink">Transcript</a>
    </footer>

    <audio id="audioElement" crossorigin="anonymous"></audio>

    <script>
      const audioFile = document.getElementById("audioFile");
      const audioSource = document.getElementById("audioSource");
      const audioEffect = document.getElementById("audioEffect");
      const reverbStrength = document.getElementById("reverbStrength");
      const filterFrequency = document.getElementById("filterFrequency");
      const monitorOutput = document.getElementById("monitorOutput");
      const startButton = document.getElementById("startButton");
      const stopButton = document.getElementById("stopButton");
      const audioStatus = document.getElementById("audioStatus");
      const lineStyle = document.getElementById("lineStyle");
      const lineWidth = document.getElementById("lineWidth");
      const cellSize = document.getElementById("cellSize");
      const drawLines = document.getElementById("drawLines");
      const drawCells = document.getElementById("drawCells");
      const pixelFilter = document.getElementById("pixelFilter");
      const useWaveform = document.getElementById("useWaveform");
      const limitMotion = document.getElementById("limitMotion");
      const resetButton = document.getElementById("resetButton");
      const copySettings = document.getElementById("copySettings");
      const settingsOutput = document.getElementById("settingsOutput");
      const visualStatus = document.getElementById("visualStatus");
      const canvas = document.getElementById("visualizer");
      const audioElement = document.getElementById("audioElement");
      const sourceLink = document.getElementById("sourceLink");
      const transcriptLink = document.getElementById("transcriptLink");

      const REPO = "venku122/tools";
      const BRANCH = "main";
      const fileName = window.location.pathname.split("/").pop();
      const slug = fileName.replace(/\.html$/i, "");

      if (sourceLink) {
        sourceLink.href = `https://github.com/${REPO}/blob/${BRANCH}/tools/${fileName}`;
      }
      if (transcriptLink) {
        transcriptLink.href = `https://github.com/${REPO}/blob/${BRANCH}/transcripts/${slug}.md`;
      }

      const state = {
        audioContext: null,
        analyser: null,
        sourceNode: null,
        convolver: null,
        filter: null,
        mediaStream: null,
        colony: null,
        rafId: null,
        lastFrameTime: 0,
        isRunning: false,
        numSamples: 256,
        pendingUrl: null,
      };

      class Automota {
        constructor(xIndex, yIndex) {
          this.xIndex = xIndex;
          this.yIndex = yIndex;
          this.currentState = 0;
          this.nextState = 0;
          this.neighbors = [];
        }

        calculateNextGeneration() {
          let living = 0;
          for (const neighbor of this.neighbors) {
            if (neighbor && neighbor.currentState > 0) {
              living += 1;
            }
          }

          if (this.currentState > 0) {
            if (living < 2) {
              this.nextState = 0;
            } else if (living === 2 || living === 3) {
              this.nextState = this.currentState + 1;
            } else if (living > 3) {
              this.nextState = 0;
            }
          } else if (living === 3) {
            this.nextState = 1;
          }
        }

        update() {
          this.currentState = this.nextState;
          this.nextState = 0;
        }

        draw(ctx, bounds, options) {
          if (this.currentState < 1) {
            return;
          }

          const { width, height, xSize, ySize } = bounds;
          const {
            lineWidth: strokeWidth,
            lineStyle: style,
            radiusScale,
            drawLines: shouldDrawLines,
            drawCells: shouldDrawCells,
          } = options;

          const xPos = (width / xSize) * this.xIndex;
          const yPos = (height / ySize) * this.yIndex;
          const shade = this.currentState - 1;
          const red = 255 - this.xIndex - 10 * shade;
          const green = Math.max(0, this.yIndex - this.xIndex) - this.currentState * 3;
          const blue = this.xIndex - 10 * shade;

          const resolvedStyle = style === "random"
            ? ["straight", "quadratic", "cubic"][Math.floor(Math.random() * 3)]
            : style;

          ctx.save();
          ctx.strokeStyle = `rgba(${red}, ${green}, ${blue}, 1)`;
          ctx.lineWidth = Number(strokeWidth);

          if (shouldDrawLines) {
            if (this.yIndex < Math.round(ySize / 2)) {
              const controlY = height / 4 / this.currentState;
              if (resolvedStyle === "straight") {
                drawStraightLine(ctx, width / 2, 0, xPos, yPos);
              } else if (resolvedStyle === "quadratic") {
                drawQuadraticCurve(ctx, width / 2, 0, xPos, controlY, xPos, yPos);
              } else {
                drawCubicCurve(ctx, width / 2, 0, width / 2, height / 4, xPos, controlY, xPos, yPos);
              }
            } else {
              const yFlip = height - height / 4 / this.currentState;
              const controlY = height - height / 4;
              if (resolvedStyle === "straight") {
                drawStraightLine(ctx, width / 2, height, xPos, yPos);
              } else if (resolvedStyle === "quadratic") {
                drawQuadraticCurve(ctx, width / 2, height, xPos, yFlip, xPos, yPos);
              } else {
                drawCubicCurve(ctx, width / 2, height, width / 2, controlY, xPos, yFlip, xPos, yPos);
              }
            }
          }

          if (shouldDrawCells) {
            ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, 1)`;
            ctx.beginPath();
            ctx.arc(xPos, yPos, 2 * Math.min(this.currentState * radiusScale, 10 * radiusScale), 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
          }

          if (this.currentState > 10) {
            this.currentState = 0;
            this.nextState = 0;
          }
          ctx.restore();
        }
      }

      class Colony {
        constructor(width, height, xSize, ySize) {
          this.width = width;
          this.height = height;
          this.xSize = xSize;
          this.ySize = ySize;
          this.automota = Array.from({ length: xSize }, (_, xIndex) => (
            Array.from({ length: ySize }, (_, yIndex) => new Automota(xIndex, yIndex))
          ));
          this.assignNeighbors();
        }

        assignNeighbors() {
          for (let x = 0; x < this.xSize; x += 1) {
            for (let y = 0; y < this.ySize; y += 1) {
              const neighbors = [];
              neighbors[0] = x - 1 > 0 ? this.automota[x - 1][y - 1] : null;
              neighbors[1] = y - 1 > 0 ? this.automota[x][y - 1] : null;
              neighbors[2] = x + 1 < this.xSize && y - 1 > 0 ? this.automota[x + 1][y - 1] : null;
              neighbors[3] = x - 1 > 0 ? this.automota[x - 1][y] : null;
              neighbors[4] = x + 1 < this.xSize ? this.automota[x + 1][y] : null;
              neighbors[5] = x - 1 > 0 && y + 1 < this.ySize ? this.automota[x - 1][y + 1] : null;
              neighbors[6] = y + 1 < this.ySize ? this.automota[x][y + 1] : null;
              neighbors[7] = x + 1 < this.xSize && y + 1 < this.ySize ? this.automota[x + 1][y + 1] : null;
              this.automota[x][y].neighbors = neighbors;
            }
          }
        }

        update() {
          for (let x = 0; x < this.xSize; x += 1) {
            for (let y = 0; y < this.ySize; y += 1) {
              this.automota[x][y].calculateNextGeneration();
            }
          }
          for (let x = 0; x < this.xSize; x += 1) {
            for (let y = 0; y < this.ySize; y += 1) {
              this.automota[x][y].update();
            }
          }
        }

        draw(ctx, options) {
          const bounds = {
            width: this.width,
            height: this.height,
            xSize: this.xSize,
            ySize: this.ySize,
          };
          for (let x = 0; x < this.xSize; x += 1) {
            for (let y = 0; y < this.ySize; y += 1) {
              this.automota[x][y].draw(ctx, bounds, options);
            }
          }
        }

        clear() {
          for (let x = 0; x < this.xSize; x += 1) {
            for (let y = 0; y < this.ySize; y += 1) {
              this.automota[x][y].currentState = 0;
              this.automota[x][y].nextState = 0;
            }
          }
        }
      }

      function drawQuadraticCurve(ctx, originX, originY, cpX, cpY, targetX, targetY) {
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.quadraticCurveTo(cpX, cpY, targetX, targetY);
        ctx.stroke();
      }

      function drawStraightLine(ctx, originX, originY, targetX, targetY) {
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.lineTo(targetX, targetY);
        ctx.stroke();
      }

      function drawCubicCurve(ctx, originX, originY, cp1X, cp1Y, cp2X, cp2Y, targetX, targetY) {
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, targetX, targetY);
        ctx.stroke();
      }

      function setStatus(element, message, tone = "info") {
        element.textContent = message;
        element.dataset.tone = tone;
      }

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const ratio = window.devicePixelRatio || 1;
        canvas.width = Math.max(1, Math.floor(rect.width * ratio));
        canvas.height = Math.max(1, Math.floor(rect.height * ratio));
        const ctx = canvas.getContext("2d");
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        if (state.colony) {
          state.colony.width = rect.width;
          state.colony.height = rect.height;
        }
      }

      function createAudioContext() {
        if (!state.audioContext) {
          state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return state.audioContext;
      }

      function createImpulseResponse(context, strength) {
        const duration = Math.max(0.1, Number(strength) * 2.2);
        const rate = context.sampleRate;
        const length = Math.floor(duration * rate);
        const impulse = context.createBuffer(2, length, rate);
        for (let channel = 0; channel < impulse.numberOfChannels; channel += 1) {
          const data = impulse.getChannelData(channel);
          for (let i = 0; i < length; i += 1) {
            data[i] = (Math.random() * 2 - 1) * (1 - i / length);
          }
        }
        return impulse;
      }

      function connectAudioGraph() {
        if (!state.analyser || !state.audioContext) {
          return;
        }

        state.analyser.disconnect();
        state.convolver?.disconnect();
        state.filter?.disconnect();

        const effect = audioEffect.value;
        const shouldMonitor = monitorOutput.checked;

        if (effect === "reverb" && state.convolver) {
          state.analyser.connect(state.convolver);
          if (shouldMonitor) {
            state.convolver.connect(state.audioContext.destination);
          }
        } else if (effect === "filter" && state.filter) {
          state.analyser.connect(state.filter);
          if (shouldMonitor) {
            state.filter.connect(state.audioContext.destination);
          }
        } else if (shouldMonitor) {
          state.analyser.connect(state.audioContext.destination);
        }
      }

      async function setupAudioSource() {
        const context = createAudioContext();
        state.analyser = context.createAnalyser();
        state.analyser.fftSize = state.numSamples;
        state.convolver = context.createConvolver();
        state.filter = context.createBiquadFilter();
        state.filter.type = "lowpass";
        state.filter.frequency.value = Number(filterFrequency.value);
        state.convolver.buffer = createImpulseResponse(context, reverbStrength.value);

        if (audioSource.value === "mic") {
          try {
            state.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            state.sourceNode = context.createMediaStreamSource(state.mediaStream);
            setStatus(audioStatus, "Microphone connected.", "success");
          } catch (error) {
            setStatus(audioStatus, "Microphone access denied. Upload a file instead.", "error");
            audioSource.value = "file";
          }
        }

        if (audioSource.value === "file") {
          if (!audioElement.src) {
            setStatus(audioStatus, "Upload an audio file to start.", "error");
            return false;
          }
          state.sourceNode = context.createMediaElementSource(audioElement);
          setStatus(audioStatus, "Audio file ready.", "success");
        }

        state.sourceNode.connect(state.analyser);
        connectAudioGraph();
        return true;
      }

      function createColony() {
        const rect = canvas.getBoundingClientRect();
        const xSize = Math.floor(state.numSamples / 2);
        const ySize = Math.floor(state.numSamples / 2);
        state.colony = new Colony(rect.width, rect.height, xSize, ySize);
      }

      function updateAutomotaFromAudio(dataArray) {
        const half = state.numSamples / 2;
        const quarter = state.numSamples / 4;
        for (let i = 0; i < quarter; i += 1) {
          if (dataArray[i] > 100) {
            state.colony.automota[i][Math.round(state.colony.ySize / 2)].nextState = Math.round(dataArray[i] / 25);
          }
        }
        let extraCount = 0;
        for (let i = half - 1; i > quarter; i -= 1) {
          if (dataArray[extraCount] > 100) {
            state.colony.automota[i][Math.round(state.colony.ySize / 2)].nextState = Math.round(dataArray[extraCount] / 25);
          }
          extraCount += 1;
        }
      }

      function applyPixelFilter(ctx, width, height) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const { data } = imageData;
        for (let i = 0; i < data.length; i += 4) {
          if (data[i] !== 0 || data[i + 1] !== 0) {
            data[i] = Math.round(Math.random() * data[i] * 2);
            data[i + 1] = 0;
            data[i + 2] = Math.round(Math.random() * data[i + 2] * 2);
          }
        }
        ctx.putImageData(imageData, 0, 0);
      }

      function drawFrame(timestamp) {
        if (!state.isRunning) {
          return;
        }

        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        const frameInterval = prefersReducedMotion || limitMotion.checked ? 100 : 0;
        if (frameInterval && timestamp - state.lastFrameTime < frameInterval) {
          state.rafId = window.requestAnimationFrame(drawFrame);
          return;
        }
        state.lastFrameTime = timestamp;

        const ctx = canvas.getContext("2d");
        const rect = canvas.getBoundingClientRect();
        ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
        ctx.fillRect(0, 0, rect.width, rect.height);

        const options = {
          lineWidth: Number(lineWidth.value),
          lineStyle: lineStyle.value,
          radiusScale: Number(cellSize.value),
          drawLines: drawLines.checked,
          drawCells: drawCells.checked,
        };

        state.colony.draw(ctx, options);
        state.colony.update();

        const data = new Uint8Array(state.numSamples);
        if (useWaveform.checked) {
          state.analyser.getByteTimeDomainData(data);
        } else {
          state.analyser.getByteFrequencyData(data);
        }
        updateAutomotaFromAudio(data);

        if (pixelFilter.checked) {
          applyPixelFilter(ctx, rect.width, rect.height);
        }

        state.rafId = window.requestAnimationFrame(drawFrame);
      }

      function updateSettingsSnapshot() {
        const snapshot = {
          audio: {
            source: audioSource.value,
            effect: audioEffect.value,
            reverbStrength: Number(reverbStrength.value),
            filterFrequency: Number(filterFrequency.value),
            monitorOutput: monitorOutput.checked,
          },
          visualizer: {
            lineStyle: lineStyle.value,
            lineWidth: Number(lineWidth.value),
            cellSize: Number(cellSize.value),
            drawLines: drawLines.checked,
            drawCells: drawCells.checked,
            pixelFilter: pixelFilter.checked,
            waveform: useWaveform.checked,
            reducedMotion: limitMotion.checked,
          },
        };
        settingsOutput.value = JSON.stringify(snapshot, null, 2);
      }

      async function startVisualizer() {
        if (state.isRunning) {
          return;
        }

        const ready = await setupAudioSource();
        if (!ready) {
          return;
        }

        createColony();
        resizeCanvas();
        state.isRunning = true;
        stopButton.disabled = false;
        startButton.disabled = true;

        if (audioSource.value === "file") {
          try {
            await audioElement.play();
          } catch (error) {
            setStatus(audioStatus, "Press play in the audio controls to start playback.", "error");
          }
        }

        setStatus(visualStatus, "Visualizer running.", "success");
        state.rafId = window.requestAnimationFrame(drawFrame);
      }

      function stopVisualizer() {
        state.isRunning = false;
        startButton.disabled = false;
        stopButton.disabled = true;
        if (state.rafId) {
          window.cancelAnimationFrame(state.rafId);
        }
        if (audioSource.value === "file") {
          audioElement.pause();
        }
        setStatus(visualStatus, "Visualizer stopped.", "info");
      }

      function resetAutomota() {
        if (state.colony) {
          state.colony.clear();
        }
      }

      async function copySettingsSnapshot() {
        if (!settingsOutput.value) {
          setStatus(visualStatus, "No settings to copy yet.", "error");
          return;
        }
        try {
          await navigator.clipboard.writeText(settingsOutput.value);
          setStatus(visualStatus, "Settings copied to clipboard.", "success");
        } catch (error) {
          settingsOutput.select();
          document.execCommand("copy");
          setStatus(visualStatus, "Settings copied to clipboard.", "success");
        }
      }

      function handleAudioFileChange(event) {
        const [file] = event.target.files;
        if (!file) {
          return;
        }
        if (state.pendingUrl) {
          URL.revokeObjectURL(state.pendingUrl);
        }
        const url = URL.createObjectURL(file);
        state.pendingUrl = url;
        audioElement.src = url;
        audioElement.loop = true;
        audioElement.volume = 0.4;
        setStatus(audioStatus, `Loaded ${file.name}.`, "success");
      }

      function handleEffectChange() {
        if (!state.audioContext || !state.analyser) {
          return;
        }
        state.filter.frequency.value = Number(filterFrequency.value);
        state.convolver.buffer = createImpulseResponse(state.audioContext, reverbStrength.value);
        connectAudioGraph();
        updateSettingsSnapshot();
      }

      function handleSourceChange() {
        if (state.isRunning) {
          stopVisualizer();
        }
        if (state.mediaStream) {
          state.mediaStream.getTracks().forEach((track) => track.stop());
          state.mediaStream = null;
        }
        setStatus(audioStatus, "Source switched. Press start to reinitialize audio.", "info");
        updateSettingsSnapshot();
      }

      audioFile.addEventListener("change", handleAudioFileChange);
      audioSource.addEventListener("change", handleSourceChange);
      audioEffect.addEventListener("change", handleEffectChange);
      reverbStrength.addEventListener("input", handleEffectChange);
      filterFrequency.addEventListener("input", handleEffectChange);
      monitorOutput.addEventListener("change", handleEffectChange);
      startButton.addEventListener("click", startVisualizer);
      stopButton.addEventListener("click", stopVisualizer);
      resetButton.addEventListener("click", resetAutomota);
      copySettings.addEventListener("click", copySettingsSnapshot);

      [
        lineStyle,
        lineWidth,
        cellSize,
        drawLines,
        drawCells,
        pixelFilter,
        useWaveform,
        limitMotion,
      ].forEach((control) => {
        control.addEventListener("input", updateSettingsSnapshot);
        control.addEventListener("change", updateSettingsSnapshot);
      });

      window.addEventListener("resize", () => {
        resizeCanvas();
        updateSettingsSnapshot();
      });

      updateSettingsSnapshot();
      resizeCanvas();
    </script>
  </body>
</html>
